
//BITMAP IMAGES FOR INTRO ANIMATION
const unsigned char PROGMEM a5 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
  0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x7C, 0xFC, 0x78, 0x7C, 0x03, 0xF0, 0xC6, 0x30, 0xCC, 0x66,
  0x01, 0xC0, 0xC6, 0x31, 0x86, 0x66, 0x01, 0xC0, 0x70, 0x31, 0x86, 0x66, 0x01, 0xC0, 0x0C, 0x31,
  0x86, 0x7C, 0x01, 0xC0, 0xC6, 0x31, 0x86, 0x60, 0x01, 0x80, 0xC6, 0x30, 0xCC, 0x60, 0x01, 0x80,
  0x7C, 0x30, 0x78, 0x60, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x42, 0x2C, 0x20,
  0x30, 0x78, 0x45, 0x30, 0x2C, 0x20, 0x30, 0x78,
};
const unsigned char PROGMEM a4 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF6,
  0x00, 0x00, 0x00, 0x00, 0x3F, 0xF7, 0x80, 0x00, 0x00, 0x00, 0x3F, 0xF7, 0xC0, 0x00, 0x00, 0x01,
  0x9F, 0xF7, 0xF0, 0x00, 0x00, 0x03, 0xCF, 0xF7, 0xF0, 0x00, 0x00, 0x07, 0xF7, 0xF7, 0xF8, 0x00,
  0x00, 0x07, 0xF3, 0xF7, 0xFA, 0x00, 0x00, 0x0F, 0xF9, 0xF7, 0xF7, 0x00, 0x00, 0x0F, 0xFE, 0xF7,
  0xEF, 0x00, 0x00, 0x1F, 0xFE, 0x77, 0xDF, 0x00, 0x00, 0x1F, 0xFF, 0xB7, 0xBF, 0x00, 0x00, 0x00,
  0x00, 0x07, 0x7F, 0x00, 0x00, 0x1F, 0xFC, 0x04, 0xFF, 0x00, 0x00, 0x1F, 0xF8, 0x01, 0xFF, 0x00,
  0x00, 0x1F, 0xF0, 0x03, 0xFF, 0x00, 0x00, 0x1F, 0xE8, 0x07, 0xFE, 0x00, 0x00, 0x1F, 0xDA, 0x07,
  0xFC, 0x00, 0x00, 0x1F, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x7B, 0x7F, 0xFE, 0x00, 0x00, 0x0E,
  0xFB, 0xBF, 0xFE, 0x00, 0x00, 0x09, 0xFB, 0xDF, 0xFC, 0x00, 0x00, 0x03, 0xFB, 0xEF, 0xF8, 0x00,
  0x00, 0x07, 0xFB, 0xF7, 0xF8, 0x00, 0x00, 0x03, 0xFB, 0xFB, 0xF0, 0x00, 0x00, 0x01, 0xFB, 0xFD,
  0xC0, 0x00, 0x00, 0x00, 0xFB, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x1B, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x2C, 0x20, 0x30,
  0x78, 0x39, 0x46, 0x2C, 0x20, 0x30, 0x78, 0x30,
};
const unsigned char PROGMEM a3 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF8,
  0x80, 0x00, 0x00, 0x00, 0x1B, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x7D, 0xFE, 0xE0, 0x00, 0x00, 0x00,
  0xFC, 0xFE, 0xF0, 0x00, 0x00, 0x01, 0xFE, 0x7E, 0xF8, 0x00, 0x00, 0x03, 0xFF, 0xBE, 0xFC, 0x00,
  0x00, 0x07, 0xFF, 0xDE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xFE, 0x00, 0x00, 0x0F, 0xF0, 0x06,
  0xFE, 0x00, 0x00, 0x0F, 0xF0, 0x02, 0xFE, 0x00, 0x00, 0x1F, 0xE0, 0x00, 0xFC, 0x00, 0x00, 0x1F,
  0xC0, 0x00, 0xF9, 0x00, 0x00, 0x1F, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x1E, 0x40, 0x00, 0xE7, 0x00,
  0x00, 0x1C, 0xC0, 0x00, 0xCF, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x9F, 0x00, 0x00, 0x11, 0xC0, 0x00,
  0x3F, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x7F, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0xFE, 0x00, 0x00, 0x0F,
  0xD0, 0x01, 0xFC, 0x00, 0x00, 0x0F, 0xD8, 0x03, 0xFC, 0x00, 0x00, 0x07, 0xDC, 0x00, 0x00, 0x00,
  0x00, 0x07, 0xDC, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xDE, 0x7F, 0xF0, 0x00, 0x00, 0x01, 0xDF, 0x3F,
  0xE0, 0x00, 0x00, 0x00, 0xDF, 0x9F, 0xC0, 0x00, 0x00, 0x00, 0x1F, 0xCF, 0x00, 0x00, 0x00, 0x00,
  0x1F, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x20, 0x30, 0x78,
  0x30, 0x37, 0x2C, 0x20, 0x30, 0x78, 0x42, 0x43,
};
const unsigned char PROGMEM a2 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x78,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x9F, 0x80, 0x00, 0x00, 0x00,
  0xFF, 0xCF, 0x80, 0x00, 0x00, 0x01, 0xFF, 0xE7, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xB0, 0x00,
  0x00, 0x07, 0xF0, 0x01, 0xB8, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0xBC, 0x00, 0x00, 0x0F, 0xC0, 0x00,
  0xBE, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x3F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x1C,
  0x00, 0x00, 0x3F, 0x00, 0x00, 0x19, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x13, 0x00, 0x00, 0x38, 0x00,
  0x00, 0x07, 0x00, 0x00, 0x33, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x27, 0x00, 0x00, 0x1F, 0x00, 0x00,
  0x0F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x0F,
  0x40, 0x00, 0x7C, 0x00, 0x00, 0x0F, 0x60, 0x00, 0xFC, 0x00, 0x00, 0x07, 0x70, 0x01, 0xF8, 0x00,
  0x00, 0x03, 0x78, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7D, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x7C, 0xFF,
  0xE0, 0x00, 0x00, 0x00, 0x7E, 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00,
  0x0F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x07, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x78, 0x30, 0x30,
  0x2C, 0x20, 0x30, 0x78, 0x30, 0x30, 0x2C, 0x20,
};
const unsigned char PROGMEM a1 [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xBC,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xEF, 0x80, 0x00, 0x00, 0x00,
  0x3F, 0xF7, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x03, 0xE0, 0x00, 0x00, 0x03, 0xC0, 0x01, 0xE0, 0x00,
  0x00, 0x07, 0xC0, 0x00, 0xE8, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x6C, 0x00, 0x00, 0x0F, 0x80, 0x00,
  0x2E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x12,
  0x00, 0x00, 0x0F, 0x00, 0x00, 0x06, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0F, 0x00,
  0x00, 0x1E, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1E, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x03, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x1E,
  0x00, 0x00, 0x0E, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
  0x00, 0x03, 0xC0, 0x00, 0x78, 0x00, 0x00, 0x03, 0xE0, 0x00, 0xF8, 0x00, 0x00, 0x03, 0xF0, 0x01,
  0xF0, 0x00, 0x00, 0x00, 0xF9, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x7D, 0xFF, 0x80, 0x00, 0x00, 0x00,
  0x1E, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x30, 0x30, 0x2C,
  0x20, 0x30, 0x78, 0x30, 0x30, 0x2C, 0x20, 0x30,
};
const unsigned char PROGMEM all_logo [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x07, 0xBC, 0x00, 0x00, 0x1C, 0xF0, 0x00, 0x00, 0x0F, 0xE0, 0x00, 0x00, 0x3F, 0xC0, 0x00,
  0x00, 0x1F, 0xDE, 0x00, 0x00, 0x3E, 0x7C, 0x00, 0x00, 0x6F, 0xF8, 0x00, 0x00, 0xFF, 0xD8, 0x00,
  0x00, 0x7F, 0xEF, 0x80, 0x00, 0xFF, 0x3F, 0x00, 0x01, 0xF7, 0xFA, 0x00, 0x00, 0xFF, 0xDE, 0x00,
  0x00, 0x3F, 0xF7, 0xC0, 0x01, 0xFF, 0x9F, 0x00, 0x03, 0xF3, 0xFB, 0x00, 0x06, 0x7F, 0xDF, 0x00,
  0x01, 0x80, 0x03, 0xE0, 0x03, 0xFF, 0xCF, 0x40, 0x07, 0xF9, 0xFB, 0x80, 0x0F, 0x3F, 0xDF, 0x80,
  0x03, 0xC0, 0x01, 0xE0, 0x00, 0x00, 0x0F, 0x60, 0x0F, 0xFE, 0xFB, 0xC0, 0x1F, 0xDF, 0xDF, 0xC0,
  0x07, 0xC0, 0x00, 0xE8, 0x0F, 0xE0, 0x03, 0x70, 0x1F, 0xFF, 0x7B, 0xE0, 0x1F, 0xCF, 0xDF, 0xE0,
  0x07, 0xC0, 0x00, 0x6C, 0x1F, 0xC0, 0x01, 0x78, 0x00, 0x00, 0x3B, 0xF0, 0x3F, 0xE7, 0xDF, 0xC0,
  0x0F, 0x80, 0x00, 0x2E, 0x1F, 0x80, 0x01, 0x7C, 0x3F, 0xC0, 0x1B, 0xF0, 0x3F, 0xFB, 0xDF, 0xA0,
  0x0E, 0x00, 0x00, 0x0E, 0x3F, 0x00, 0x00, 0x7C, 0x3F, 0xC0, 0x0B, 0xF0, 0x7F, 0xF9, 0xDF, 0x70,
  0x1C, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x7C, 0x7F, 0x80, 0x03, 0xF0, 0x7F, 0xFE, 0xDE, 0xF8,
  0x12, 0x00, 0x00, 0x0F, 0x38, 0x00, 0x00, 0x7C, 0x7F, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x1D, 0xF8,
  0x06, 0x00, 0x00, 0x0F, 0x32, 0x00, 0x00, 0x7C, 0x7C, 0x00, 0x03, 0xC8, 0x7F, 0xF0, 0x13, 0xF8,
  0x0E, 0x00, 0x00, 0x0F, 0x26, 0x00, 0x00, 0x70, 0x79, 0x00, 0x03, 0x98, 0x7F, 0xE0, 0x07, 0xF8,
  0x1E, 0x00, 0x00, 0x0F, 0x0E, 0x00, 0x00, 0x64, 0x73, 0x00, 0x03, 0x38, 0x7F, 0xC0, 0x0F, 0xF8,
  0x1E, 0x00, 0x00, 0x0E, 0x1E, 0x00, 0x00, 0x4C, 0x67, 0x00, 0x02, 0x78, 0x7F, 0xA0, 0x1F, 0xF8,
  0x1E, 0x00, 0x00, 0x08, 0x3E, 0x00, 0x00, 0x1C, 0x47, 0x00, 0x00, 0xF8, 0x7F, 0x68, 0x1F, 0xF0,
  0x1E, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x3C, 0x1F, 0x00, 0x01, 0xF8, 0x7C, 0xE8, 0x00, 0x00,
  0x1E, 0x00, 0x00, 0x0E, 0x3E, 0x00, 0x00, 0x7C, 0x3F, 0x00, 0x03, 0xF8, 0x7D, 0xED, 0xFF, 0xF8,
  0x1E, 0x00, 0x00, 0x0E, 0x1E, 0x80, 0x00, 0xF8, 0x3F, 0x40, 0x07, 0xF0, 0x3B, 0xEE, 0xFF, 0xF8,
  0x0C, 0x00, 0x00, 0x1C, 0x1E, 0xC0, 0x01, 0xF8, 0x3F, 0x60, 0x0F, 0xF0, 0x27, 0xEF, 0x7F, 0xF0,
  0x00, 0x00, 0x00, 0x38, 0x0E, 0xE0, 0x03, 0xF0, 0x1F, 0x70, 0x00, 0x00, 0x0F, 0xEF, 0xBF, 0xE0,
  0x03, 0xC0, 0x00, 0x78, 0x06, 0xF0, 0x00, 0x00, 0x1F, 0x73, 0xFF, 0xE0, 0x1F, 0xEF, 0xDF, 0xE0,
  0x03, 0xE0, 0x00, 0xF8, 0x06, 0xFB, 0xFF, 0xC0, 0x0F, 0x79, 0xFF, 0xC0, 0x0F, 0xEF, 0xEF, 0xC0,
  0x03, 0xF0, 0x01, 0xF0, 0x00, 0xF9, 0xFF, 0xC0, 0x07, 0x7C, 0xFF, 0x80, 0x07, 0xEF, 0xF7, 0x00,
  0x00, 0xF9, 0xF8, 0x00, 0x00, 0xFC, 0xFF, 0x80, 0x03, 0x7E, 0x7F, 0x00, 0x03, 0xEF, 0xFB, 0x00,
  0x00, 0x7D, 0xFF, 0x80, 0x00, 0x7E, 0x7E, 0x00, 0x00, 0x7F, 0x3C, 0x00, 0x00, 0xEF, 0xFC, 0x00,
  0x00, 0x1E, 0xFF, 0x00, 0x00, 0x1F, 0x3C, 0x00, 0x00, 0x7F, 0x98, 0x00, 0x00, 0x6F, 0xF8, 0x00,
  0x00, 0x06, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x07, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x3E, 0x7E, 0x3C, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x63, 0x18, 0x66, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x63, 0x18, 0xC3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x38, 0x18, 0xC3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x06, 0x18, 0xC3, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x63, 0x18, 0xC3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x63, 0x18, 0x66, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3E, 0x18, 0x3C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


///////////////////////////////////////////////////
// INCLUDE||DEFINE SECTION
#include <SPI.h>                        // Library necessary                      
#include <Wire.h>                       // Library necessary
#include <Adafruit_GFX.h>               // Library for Graphics||Bitmaps||Fonts
#include <Adafruit_SSD1306.h>           // Library for (not only) the 128x64 OLED display
#include <Adafruit_Sensor.h>            // Library necessary
#include "Adafruit_TCS34725.h"
#define SCL_PORT PORTC
#define SCL_PIN 3
#define SDA_PORT PORTC
#define SDA_PIN 2
#include <SoftI2CMaster.h>
#include "Adafruit_TSL2591Soft.h"
#include <EEPROM.h>                     // Library for using the EEPROM memory
#define OLED_RESET 8                    // OLED reset pin set to digitalPin 4 // I2C ONLY
Adafruit_SSD1306 display(OLED_RESET);   // I2C ONLY
///// Constants for calibration
#define TCS34725_R_Coef 0.136
#define TCS34725_G_Coef 1.000
#define TCS34725_B_Coef -0.444
#define TCS34725_GA 1.0
#define TCS34725_DF 310.0
#define TCS34725_CT_Coef 3810.0
#define TCS34725_CT_Offset 1391.0
#define C_const 129
#define DomeMultiplier 2.17             // Multiplier when using a white translucid Dome covering the Sensor
#define DomeSum
///////////////////////////////////////////////////
// INT||FLOAT||STRING||BOOLEAN
int Rp = 2;                             // Metering button pin
int Bn1p = 3;                           // + increment button pin
int Bn2p = 4;                           // - increment button pin
int Tdisplay;                           // State of shutter speed value display (fractional, seconds, minutes)
int Tfr;
int taddr = 0;                          // Address to write tcm to EEPROM
int Am = 15;                            // Starts Photo Mode with f2.8
int tca;                                // Shutter angle selector
int Saddr = 1;                          // Address to write Sv to EEPROM
int Buzzer = 9;                         // Buzzer for Button confirmation
int x_vmode = 0;                        // X Position - cine/video/...
int y_vmode = 32;                       // Y Position - cine/video/...
///////////////////////////////////////////////////
float lux;                              // Lux value from TSL2561
float ct;                               // Color Temp value from TCS34725
float EV;                               // EV value for PhotoMode
float Tmin;                             // Time in minutes
///////////////////////////////////////////////////
boolean Bn1;                            // + increment button state
boolean Bn2;                            // - increment button state
boolean R;                              // Metering button state
boolean ISOmode = 0;                    // ISO mode state
boolean Shuttermode = 0;                // Shutter mode state for Cine or Photo
boolean save = 0;                       // Save to EEPROM state
boolean freeze = 0;                     // Freezes the Shutter (CINE) || Aperture (Photo)
boolean State = 0;                      // Activate Shuttermode Animation
boolean Anglemode = 0 ;                 // Activate shutter angle mode at 24fps
///////////////////////////////////////////////////
// ARRAYS for Photo and Cine values
int S [] = {100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600}; //ISO array
float A [] = {0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.4, 1.6, 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5.0, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22, 25, 29, 32, 36, 40, 45, 51, 57, 64, 72, 80, 90}; // Aperture array
int t_cine [] = {8, 16, 24, 25, 30, 48, 50, 60, 96, 100, 120}; // fps Cine/video array obs: making double time at the equation
int t_angle [] = {360, 270, 180, 178.8, 144, 90, 72, 45}; // shutter angle @ 24fps
///////////////////////////////////////////////////
// EEPROM for memory recording
int Sm =          EEPROM.read(1);
int tcm =         EEPROM.read(0);
///////////////////////////////////////////////////
// TCS 34725
class ColorSensor {
  public:

    void getColorTemp();
    uint16_t r, g, b, c, ir;
    uint16_t ct, lux, r_comp, g_comp, b_comp;
    float cpl;
};

void ColorSensor::getColorTemp() {


  Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_101MS, TCS34725_GAIN_1X);

  tcs.getRawData(&r, &g, &b, &c);
  //lux = tcs.calculateLux(r, g, b);
  // DN40 calculations
  ir = (r + g + b > c) ? (r + g + b - c) / 2 : 0;
  r_comp = r - ir;
  g_comp = g - ir;
  b_comp = b - ir;
  //c_comp = c - ir;

  cpl = (700) / (TCS34725_GA * TCS34725_DF);
  lux = (TCS34725_R_Coef * float(r_comp) + TCS34725_G_Coef * float(g_comp) + TCS34725_B_Coef * float(b_comp)) / cpl;
  ct = TCS34725_CT_Coef * float(b_comp) / float(r_comp) + TCS34725_CT_Offset;
//ct = ct*DomeSum;

}
ColorSensor rgb_sensor;
///////////////////////////////////////////////////
// SETUP
///////////////////////////////////////////////////
void setup() {
  // PINMODE
  pinMode(Bn1p, INPUT_PULLUP);
  pinMode(Bn2p, INPUT_PULLUP);
  pinMode(Rp, INPUT_PULLUP);
  pinMode(Buzzer, OUTPUT);                    // not necessary
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  display.begin(SSD1306_SWITCHCAPVCC, 0x3D);  //Initialize with the I2C addr 0x3D (for the 128x64 OLED)
  display.clearDisplay();                     // Clean display before Intro Animation
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  introanimation();                           // intro ANIMATION
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  // IF NO MEMORY WAS RECORDED BEFORE, START WITH THIS VALUES otherwise it will read "255"
  if (tcm > (sizeof(t_cine) / sizeof(int) - 1))
  {
    tcm = 2;
  }
  //if (Am > (sizeof(A)/sizeof(float)-1))
  //{Am = 4;}
  if (Sm > (sizeof(S) / sizeof(int) - 1))
  {
    Sm = 2;
  }

  lux = getLux();   // MAIN command to get a new exposure
  rgb_sensor.getColorTemp(); // MAIN command to get a new WB Value

}
//////////////////////////////////////////////////////////////////////////////////////////////////////
void loop() {

  Bn1 = digitalRead(Bn1p);
  Bn2 = digitalRead(Bn2p);
  R = digitalRead(Rp);

  //IF BUTTON (-) AND (M) ARE BOTH PRESSED, SAVE EEPROM DATA AND FREEZES THE SETTINGS

  if (Bn1 == 0 & R == 0)
  {
    save = 1;
    freeze = 1;
  }
  while (Bn1 == 0 & R == 0)
  {
    delay(100);
    Bn1 = digitalRead(Bn1p);
    Bn2 = digitalRead(Bn2p);
    R = digitalRead(Rp);
  }

  if (save == 1)
  {
    if (tcm == 2) {
      Anglemode = 1;
      tca = 2;
    } else {
      Anglemode = 0;
    }
    EEPROM.write(taddr, tcm);
    //EEPROM.write(Aaddr,Am);
    EEPROM.write(Saddr, Sm);
    //EEPROM.write(Maddr,Shuttermode);
    tone(Buzzer, 800, 50); //SOUNDDD
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(5, 20);
    display.println(F("Saved"));
    display.setCursor(5, 40);
    display.setTextSize(1);
    display.println(F("Freezed"));
    display.display();
    delay(500);
    display.clearDisplay();
    save = 0;
    Bn1 = 1;
    Bn2 = 1;
  }

  if (Anglemode == 1)
  {
    //READ BUTTON (+) AND INCREMENT ANGLE VALUE
    if (Bn1 == 0)
    {
      if (tca >= (sizeof(t_angle) / sizeof(int) - 1))
      {
        tca = 0;
      }
      else {
        tca = tca + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT ANGLE VALUE
    if (Bn2 == 0)
    {
      if (tca == 0) {
        tca = (sizeof(t_angle) / sizeof(int) - 1);
      }
      else {
        tca = tca - 1;
      }
    }
  }

  if (freeze == 0)
  {
    //READ BUTTON (+) AND INCREMENT SHUTTER VALUE
    if (Bn1 == 0)
    {
      if (tcm >= (sizeof(t_cine) / sizeof(int) - 1))
      {
        tcm = 0;
      }
      else {
        tcm = tcm + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT SHUTTER VALUE
    if (Bn2 == 0)
    {
      if (tcm == 0) {
        tcm = (sizeof(t_cine) / sizeof(int) - 1);
      }
      else {
        tcm = tcm - 1;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF BUTTON (-) AND (M) ARE BOTH PRESSED, CHANGE SHUTTER MODE
  if (Bn2 == 0 & R == 0)
  {
    State = 1 - State;
    anima_modo_1();
    delay(100);
  }
  if (State == 1)
  {
    Shuttermode = 1; /*Photo Mode (Aperture Priority)*/
  }
  else
  {
    Shuttermode = 0; /*Cine Mode (Aperture Priority)*/
  }

  //READ BUTTON (+) AND INCREMENT APERTURE VALUE
  if (freeze == 0)
  {
    if (Bn1 == 0)
    {
      if (Am >= (sizeof(A) / sizeof(float) - 1))
      {
        Am = 0;
      }
      else {
        Am = Am + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT APERTURE VALUE
    if (Bn2 == 0)
    {
      if (Am == 0)
      {
        Am = (sizeof(A) / sizeof(float) - 1);
      }
      else
      {
        Am = Am - 1;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF BUTTON (-) AND (+) ARE BOTH PRESSED, ENTER ISO MODE

  if (Bn1 == 0 & Bn2 == 0)
  {
    ISOmode = 1;
  }
  while (Bn1 == 0 & Bn2 == 0)
  {
    delay(100);
    Bn1 = digitalRead(Bn1p);
    Bn2 = digitalRead(Bn2p);
  }

  if (ISOmode == 1)
  {
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(5, 20);
    display.println(F("ISO Set"));
    display.display();
    delay(500);
    display.clearDisplay();
    save = 0;
    Bn1 = 1;
    Bn2 = 1;
  }
  while (ISOmode == 1)
  {
    Bn1 = digitalRead(Bn1p);
    Bn2 = digitalRead(Bn2p);
    if (Bn1 == 0 & Bn2 == 0)
    {
      tone(Buzzer, 400, 50); //SOUNDDD
      ISOmode = 0;
      freeze = 0;
      Anglemode = 0;
      display.clearDisplay();
      display.setTextSize(2);
      display.setTextColor(WHITE);
      display.setCursor(5, 20);
      display.println(F("Selected"));
      display.setCursor(5, 40);
      display.setTextSize(1);
      display.println(F("Unfreezed"));
      display.display();
      delay(500);
      display.clearDisplay();
    }

    //READ BUTTON (+) AND INCREMENT SENSITIVITY VALUE
    if (Bn1 == 0)
    { if (Sm >= (sizeof(S) / sizeof(int) - 1))
      {
        Sm = 0;
      }
      else {
        Sm = Sm + 1;
      }
    }
    //READ BUTTON (-) AND INCREMENT SENSITIVITY VALUE
    if (Bn2 == 0)
    { if (Sm == 0)
      {
        Sm = (sizeof(S) / sizeof(int) - 1);
      }
      else {
        Sm = Sm - 1;
      }
    }

    refresh(); // While in ISO Mode, call function for refreshing the Display

    //DELAYS FOR BUTTON HOLD
    while (Bn1 == 0)
    {
      delay(10);
      Bn1 = digitalRead(Bn1p);
    }
    while (Bn2 == 0)
    {
      delay(10);
      Bn2 = digitalRead(Bn2p);
    }
  }
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  // REFRESH AND BUTTON DEBUG

  refresh(); // While Shuttermode = 0 or 1, call function for refreshing the Display

  //DELAYS FOR BUTTON HOLD
  if (Shuttermode == 1)
  {
    while (Bn1 == 0)
    {
      delay(2);
      Bn1 = digitalRead(Bn1p);
    }
    while (Bn2 == 0)
    {
      delay(2);
      Bn2 = digitalRead(Bn2p);
    }
  } else {
    while (Bn1 == 0)
    {
      delay(10);
      Bn1 = digitalRead(Bn1p);
    }
    while (Bn2 == 0)
    {
      delay(10);
      Bn2 = digitalRead(Bn2p);
    }
  }
  delay(10);
  //////////////////////////////////////////////////////////////////////////////////////////////////////
  //IF (M) BUTTON IS PRESSED, GET A NEW LUX VALUE and COLOR TEMP VALUE
  if (R == 0)
  {
    lux = getLux();
    rgb_sensor.getColorTemp();
    tone(Buzzer, 3000, 100);
  }
} // END OF LOOP \\

//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////   FUNCTIONS   ////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
float getLux()
{
  Adafruit_TSL2591 tsl = Adafruit_TSL2591(2591);

  sensor_t sensor;
  tsl.getSensor(&sensor);


  tsl.setGain(TSL2591_GAIN_LOW);    /* 1x gain (bright light)*/
  tsl.setTiming(TSL2591_INTEGRATIONTIME_200MS); /*shortest integration time (bright light)*/

  tsl.begin();

  sensors_event_t event;
  tsl.getEvent(&event);
  uint16_t lux = event.light;
  lux = lux * DomeMultiplier; // DomeMultiplier = 2.17


  return lux;

}

void refresh()  //This function gives a new calculation based on the last illuminance value, and refreshes the display.

{
  if (Shuttermode == 0)
    //////////////////////////// CINE MODE //////////////////////
  {
    int intCinefps = t_cine[tcm];                // FPS
    float t_final;                               // shutter speed/ shutter angle
    String Ev;                                   // F stop
    int Evplus;                                  // Thirds of stop
    String Fplus[] {F("+1/3") , F("+2/3")};      // String Array of Thirds of stop
    // Formula
    if (Anglemode == 1) {
      t_final = pow((8640 / t_angle[tca]), -1);
    }
    else {
      t_final = pow(((intCinefps) * 2), -1); // Shutter Speed // Formula because intCinefps is frames per second
    }
    float N = sqrt((lux * S[Sm] * t_final) / C_const); // APERTURE in full value // eg: 2.845 -> 2.8
    float Fc = lux * 0.0929;                     // FootCandle (lux_fc)

    // Translation for printing the Display
    if ((N >= 0.5) && (N < 0.8)) {
      Ev = F("0.7");
      Evplus = 2;
    }
    if ((N >= 0.8) && (N < 0.9)) {
      Ev = F("0.7");
      Evplus = 0;
    }
    if ((N >= 0.9) && (N < 1))   {
      Ev = F("0.7");
      Evplus = 1;
    }
    if ((N >= 1.0) && (N < 1.1)) {
      Ev = F("1");
      Evplus = 2;
    }
    if ((N >= 1.1) && (N < 1.2)) {
      Ev = F("1");
      Evplus = 0;
    }
    if ((N >= 1.2) && (N < 1.4)) {
      Ev = F("1");
      Evplus = 1;
    }
    if ((N >= 1.4) && (N < 1.6)) {
      Ev = F("1.4");
      Evplus = 2;
    }
    if ((N >= 1.6) && (N < 1.8)) {
      Ev = F("1.4");
      Evplus = 0;
    }
    if ((N >= 1.8) && (N < 2))   {
      Ev = F("1.4");
      Evplus = 1;
    }
    if ((N >= 2.0) && (N < 2.2)) {
      Ev = F("2");
      Evplus = 2;
    }
    if ((N >= 2.2) && (N < 2.5)) {
      Ev = F("2");
      Evplus = 0;
    }
    if ((N >= 2.5) && (N < 2.8)) {
      Ev = F("2");
      Evplus = 1;
    }
    if ((N >= 2.8) && (N < 3.2)) {
      Ev = F("2.8");
      Evplus = 2;
    }
    if ((N >= 3.2) && (N < 3.5)) {
      Ev = F("2.8");
      Evplus = 0;
    }
    if ((N >= 3.5) && (N < 4))   {
      Ev = F("2.8");
      Evplus = 1;
    }
    if ((N >= 4.0) && (N < 4.5)) {
      Ev = F("4");
      Evplus = 2;
    }
    if ((N >= 4.5) && (N < 5.0)) {
      Ev = F("4");
      Evplus = 0;
    }
    if ((N >= 5.0) && (N < 5.6)) {
      Ev = F("4");
      Evplus = 1;
    }
    if ((N >= 5.6) && (N < 6.3)) {
      Ev = F("5.6");
      Evplus = 2;
    }
    if ((N >= 6.3) && (N < 7.1)) {
      Ev = F("5.6");
      Evplus = 0;
    }
    if ((N >= 7.1) && (N < 8))   {
      Ev = F("5.6");
      Evplus = 1;
    }
    if ((N >= 8.0) && (N < 9.0)) {
      Ev = F("8");
      Evplus = 2;
    }
    if ((N >= 9)   && (N < 10))  {
      Ev = F("8");
      Evplus = 0;
    }
    if ((N >= 10)  && (N < 11))  {
      Ev = F("8");
      Evplus = 1;
    }
    if ((N >= 11)  && (N < 13))  {
      Ev = F("11");
      Evplus = 2;
    }
    if ((N >= 13)  && (N < 14))  {
      Ev = F("11");
      Evplus = 0;
    }
    if ((N >= 14)  && (N < 16))  {
      Ev = F("11");
      Evplus = 1;
    }
    if ((N >= 16)  && (N < 18))  {
      Ev = F("16");
      Evplus = 2;
    }
    if ((N >= 18)  && (N < 20))  {
      Ev = F("16");
      Evplus = 0;
    }
    if ((N >= 20)  && (N < 22))  {
      Ev = F("16");
      Evplus = 1;
    }
    if ((N >= 22)  && (N < 25))  {
      Ev = F("22");
      Evplus = 2;
    }
    if ((N >= 25)  && (N < 29))  {
      Ev = F("22");
      Evplus = 0;
    }
    if ((N >= 29)  && (N < 32))  {
      Ev = F("22");
      Evplus = 1;
    }
    if ((N >= 32)  && (N < 36))  {
      Ev = F("32");
      Evplus = 2;
    }
    if ((N >= 36)  && (N < 40))  {
      Ev = F("32");
      Evplus = 0;
    }
    if ((N >= 40)  && (N < 45))  {
      Ev = F("32");
      Evplus = 1;
    }
    if ((N >= 45)  && (N < 51))  {
      Ev = F("45");
      Evplus = 2;
    }
    if ((N >= 51)  && (N < 57))  {
      Ev = F("45");
      Evplus = 0;
    }
    if ((N >= 57)  && (N < 64))  {
      Ev = F("45");
      Evplus = 1;
    }
    if ((N >= 64)  && (N < 72))  {
      Ev = F("64");
      Evplus = 2;
    }
    if ((N >= 72)  && (N < 80))  {
      Ev = F("64");
      Evplus = 0;
    }
    if ((N >= 80)  && (N < 90))  {
      Ev = F("64");
      Evplus = 1;
    }
    // DISPLAY PRINTING ////////////////////////////////////////
    ///////////////////////////// F STOP AND THIRDS ////////////
    display.setTextColor(WHITE);
    display.setCursor(0, 6);
    if ((N < 0.5) || (N > 90))
    { display.setTextSize(1);
      display.print("OUT OF ");
      display.setTextSize(2);
      display.println(F("RANGE!"));
    }
    else
    { // ALL OTHER VALUES
      display.setTextSize(1);
      display.print(F("f/ "));
      display.setTextSize(3);
      //display.setTextColor(WHITE);
      display.print(Ev);
      if (Evplus < 2) {
        display.setTextSize(2);
        display.println(Fplus[Evplus]);
      }
    }
    ///////////////////////////// CINE MODES FPS SHUTTER SPEED /
    if (intCinefps < 24) {
      display.setCursor(x_vmode, y_vmode);
      display.setTextSize(0);
      //display.setTextColor(WHITE);
      display.println(F("super8"));
    }
    ////////////////////////
    if (intCinefps == 24) {
      display.setCursor(x_vmode, y_vmode);
      display.setTextSize(0);
      //display.setTextColor(WHITE);
      display.println(F("cine"));
    }
    ////////////////////////
    if (intCinefps > 30) {
      display.setCursor(x_vmode, y_vmode);
      display.setTextSize(0);
      //display.setTextColor(WHITE);
      display.println(F("slow"));
    }
    ////////////////////////
    if (intCinefps == 25) {
      display.setCursor(x_vmode, y_vmode);
      display.setTextSize(0);
      //display.setTextColor(WHITE);
      display.println(F("video PAL"));
    }
    ////////////////////////
    if (intCinefps == 30) {
      display.setCursor(x_vmode, y_vmode);
      display.setTextSize(0);
      //display.setTextColor(WHITE);
      display.println(F("video NTSC"));
    }
    ////////////////////////
    display.setCursor(0, 42);
    display.setTextSize(1);
    //display.setTextColor(WHITE);
    display.print( intCinefps, 1);
    display.setTextSize(0);
    //display.setTextColor(WHITE);
    display.println(F("fps"));
    }
    display.setCursor(0, 52);
    display.setTextSize(0);
    //display.setTextColor(WHITE);
    if (Anglemode == 1) {
      display.print(t_angle[tca]);
      display.println(F(" angle"));
    }
    if (Anglemode == 0) {
      display.print(F("1/"));
      display.println(intCinefps * 2);
    }
    ////////////////////////
    display.drawLine(73, 24, 73, 62, WHITE); // LINE DIVISOR
    display.setTextSize(1);
    ////////////////////////
    display.setCursor(75, 24);
    display.print(F("ISO"));
    display.println(S[Sm]);  // ISO
    ////////////////////////
    display.setCursor(75, 34);
    display.print(F("f/"));
    display.println(N);     // APERTURE FULL VALUE
    ////////////////////////
    display.setCursor(75, 44);
    display.print(rgb_sensor.ct);
    display.println(F("K")); // KELVINS
    ////////////////////////
    display.setCursor(75, 54);
    display.print(Fc);
    display.println(F("Fc")); // FOOTCANDLES
    ////////////////////////
    display.display();
    display.clearDisplay();

  }

  else
    //////////////////////////// PHOTO MODE //////////////////////
  {
    float T = pow(A[Am], 2) * C_const / (lux * S[Sm]); //T = exposure time, in seconds
    EV = log(pow(A[Am], 2)) / log(2) + log(1 / T) / log(2);

    if (T >= 60)
    {
      Tdisplay = 0;  //Exposure is now in minutes
      Tmin = T / 60;
    }
    else if (T < 0.75)
    {
      Tdisplay = 1;  //Exposure is now in fractional form
      if (T < 0.000125) {
        Tdisplay = 3;
      }
      if ((T <= 0.000188) && (T > 0.000125)) {
        Tfr = 8000;
      }
      if ((T <= 0.000375) && (T > 0.000188)) {
        Tfr = 4000;
      }
      if ((T <= 0.00075) && (T > 0.000375)) {
        Tfr = 2000;
      }
      if ((T <= 0.0015) && (T > 0.00075)) {
        Tfr = 1000;
      }
      if ((T <= 0.003) && (T > 0.0015)) {
        Tfr = 500;
      }
      if ((T <= 0.006) && (T > 0.003)) {
        Tfr = 250;
      }
      if ((T <= 0.012333) && (T > 0.006)) {
        Tfr = 125;
      }
      if ((T <= 0.025) && (T > 0.012333)) {
        Tfr = 60;
      }
      if ((T <= 0.05) && (T > 0.025)) {
        Tfr = 30;
      }
      if ((T <= 0.095833) && (T > 0.05)) {
        Tfr = 15;
      }
      if ((T <= 0.1875) && (T > 0.095833)) {
        Tfr = 8;
      }
      if ((T <= 0.375) && (T > 0.1875)) {
        Tfr = 4;
      }
      if ((T <= 0.75) && (T > 0.375)) {
        Tfr = 2;
      }
    }
    else if ((T >= 0.75) && (T < 60))
    {
      Tdisplay = 2;  //Exposure in seconds
    }
    if (lux == 0)    //This happens if the sensor is overloaded or senses no light.
    {
      Tdisplay = 3;
    }

    display.setTextSize(1);
    display.setTextColor(WHITE);
    display.setCursor(0, 6);
    display.print(F("f/"));
    display.setTextSize(2);
    display.println(A[Am], 1);
    display.setCursor(0, 27);
    display.setTextSize(1);
    display.print(rgb_sensor.ct);
    display.println(F("K"));
    display.setCursor(0, 42);
    display.setTextSize(3);

    if (Tdisplay == 0)
    {
      display.print(Tmin, 1);
      display.println(F("m"));
    }
    else if (Tdisplay == 1)
    {
      display.print(F("1/"));
      display.println(Tfr);
    }
    else if (Tdisplay == 2)
    {
      display.print(T, 1);
      display.println(F("s"));
    }
    else if (Tdisplay == 3)
    {
      display.setTextSize(1);
      display.print("OUT OF ");
      display.setTextSize(2);
      display.println(F("RANGE!"));
    }

    display.drawLine(73, 6, 73, 35, WHITE);
    display.setTextSize(1);
    display.setCursor(76, 6);
    display.print(F("ISO"));
    display.println(S[Sm]);
    display.setCursor(76, 17);
    display.print(F("EV="));
    display.println(floor(EV + 0.5), 1);
    display.setCursor(76, 29);
    display.print(lux, 1);
    display.println(F("Lx"));

    display.display();
    display.clearDisplay();
  }
}

void introanimation() {
  uint8_t x_axis = 48;
  uint8_t y_axis = 48;
  uint8_t t_anim_1 = 120;
  uint8_t X_axis = 40;
  uint8_t Y_axis = 8;
  display.drawBitmap(0 , 0, all_logo , 128 , 64 , WHITE);
  display.display();
  delay(500);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a1, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a2, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a3, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a4, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a3, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a2, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a1, x_axis , y_axis , WHITE);
  display.display();
  delay(t_anim_1);
  display.clearDisplay();
  display.drawBitmap(X_axis, Y_axis, a5, x_axis , y_axis , WHITE);
  display.display();
  delay(500);
  display.clearDisplay();
  display.drawRoundRect(2, 22, 124, 28, 3, WHITE); //Show "2nd" splash screen
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(4, 26);
  display.println(F(" EXPOSURE METER v3.1 "));
  display.setCursor(7, 39);
  display.println(F("   with ColorTemp  "));
  display.display();
  delay(200);
  display.clearDisplay();
  display.drawRoundRect(2, 22, 124, 28, 3, WHITE); //Show "2nd" splash screen
  display.setCursor(4, 26);
  display.println(F(" EXPOSURE METER v3.1 "));
  display.setCursor(7, 39);
  display.println(F("code by Kevin Agnes"));
  display.display();
  delay(500);
  display.clearDisplay();
}




void anima_modo_1() {
  if (State == 1) {
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(0, 20);
    display.print(F("PHOTO "));
    display.println(F("Mode"));
    display.setCursor(0, 40);
    display.setTextSize(0);
    //display.setTextColor(WHITE);
    display.print(F("Aperture "));
    display.println(F("Priority"));
    display.display();
    delay(500);
    display.clearDisplay();
  }  else {
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(0, 20);
    display.print(F("CINE "));
    display.println(F("Mode"));
    display.setCursor(0, 40);
    display.setTextSize(0);
    //display.setTextColor(WHITE);
    display.print(F("Shutter "));
    display.println(F("Priority"));
    display.display();
    delay(500);
    display.clearDisplay();
  }
}



